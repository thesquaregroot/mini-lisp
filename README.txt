//
// CSE 755 Lisp Interpreter
//
//   Author: Andrew Groot
//

--------------------
Building and Running
--------------------
    This project can be successfully built with 'make' and executed with:

            ./lisp < infile > outfile

    More exactly, the interpreter take its input from standard in and prints to standard out.  So
redirection to and from files works just as well as enter expressions one at a time via the
command-line.  After each expression is collected from input, the result of evaluating it is
printed.  An EOF is required to exit the program properly.  When entering expressions manually, this
can be done with 'ctrl-d'.

------------------
Design Description
------------------
  -- The Interpreter and S-Expressions --
    This intepreter uses an object-oriented recursive descent parsing structure.  The 'interpereter'
class receives a 'tokenizer' in its constructor which it uses that to build 's_expression' objects.
The s_expression object is essentially a tree, with values at every leaf.  Lists, for example (1 2)
which is equivalent to (1 . (2 . NIL)), will be stored internally as the following binary tree:

               .
              / \
             1   .
                / \
               2  NIL

where 1 and 2 can be similar binary trees, or just leaves (also referred to as 'atoms').  All data,
including code, is represented as an s_expression and the output is also printed in this
parenthesized s-expression notation.

  -- The Symbol Table: Variables --
    The interpreter class also contains a 'symbol_table' object which defines the scope and bindings
of identifier values.  It works like a stack, with the most recent scope on top, and allowing the
re-binding of values to an identifier in a higher scope.  The most recent valid binding is what is
used when looking up the value of an identifier.  That is to say, if x is bound to the value '3' and
through another function call it's value is set to '2', inside the function '2' will be returned.
But once the function exits, '3' is again the value of x.

  -- The Symbol Table: Functions --
    The symbol_table class also serves as an accessor for function parameter lists and bodies.
Since functions can only be declared in the outer-most scope, this setup forces their global
visibility and provides simple storage and retrieval of the function's specifics.  Internally,
functions are stored as a mapping of function name and number of arguments to argument names and
function body.  In this way, functions can be overloaded to take multiple arguments or re-defined
with the later definition of a function with the same name and number of arguments.  In this
mapping, a 'definition' object (which is just a container of a string and int) maps to an
s_expression whose left subtree is the argument list and whose right subtree is the function body.

  -- Error Handling --
    Error messages are set to a string internal to the interpreter object as soon as any of its
functions finds one.  If it occurs while parsing, the token which created the error is also saved.
As NULL pointers are returned through the call stack, eventaully the 'exec' function receives a NULL
and immediately returns false.  If the main function finds that 'exec' returns false, it prints the
string generated by the interpreter's 'error' function.  This string is built using the internal
error message (and possible token) along with the current line number as tracked by the tokenizer.

------------
Grammar Used
------------
    The following grammar, based on the one given in the project description, represents the set of
all syntactically valid s-expressions (but not necessarily semantically valid) and is used by this
interpreter to generate s_expression objects:

    <start>  ::= <expr>

    <expr>   ::= atom
               | ( )
               | ( <expr> )
               | ( <expr> <list> )
               | ( <expr> . <expr> )

    <list>   ::= <expr>
               | <expr> <list>

    This grammar can be seen as a simplification of the grammar in the project description as it
contains fewer non-terminal symbols.  Furthermore, the structure of an s-expression, with elements
concatenated either in list-notion, a series of expressions separated by spaces, or as a more
general s-expression, two (likely compond) expressions at a time joined with a period, can be seen a
bit more clearly in its rules.

